## Global Rules (All Languages)
- Never assume missing context—ask clarifying questions if uncertain.  
- Never hallucinate libraries or functions—use only known, verified packages.  
- Always confirm file paths and module names exist before referencing them.  
- Always look at available code and suggest reuse of existing utilities if appropriate.  
- Always mention which cursor rules you applied in each response.  
- Always generate accompanying unit tests (e.g. `pytest`, `Jest` stubs) for any non-trivial code.  
- Confirm external dependencies: verify the latest stable version and import path before use.  
- Surface performance considerations: note time/space complexity for algorithmic code.  
- Always outline your error-handling strategy before coding.  
- Echo the minimal file/directory structure when referring to paths.  
- **Follow “Clean Code”** (Robert C. Martin) across all languages: meaningful names, small functions, avoid duplication, expressive tests, clear formatting.  
- **Adhere to SOLID principles** everywhere:  
  1. Single Responsibility – one reason to change per module/class/function.  
  2. Open/Closed – open for extension, closed for modification.  
  3. Liskov Substitution – subtypes replace base types without altering correctness.  
  4. Interface Segregation – many focused interfaces over one fat interface.  
  5. Dependency Inversion – depend on abstractions, not concretes.  

---

## Python-Specific Rules
- Avoid code comments—functions should be self-documenting with expressive names.  
- Decompose complex logic; each function should have a single responsibility.  
- Use PEP 257 docstrings (Google or NumPy style) on every public class/function.  
- Enforce type hints on all function signatures.  
- One logical statement per line; no chained assignments or multiple expressions per line.  
- Fail fast with clear exceptions: validate inputs at entry and raise precise `ValueError` or custom exceptions.  
- Single exit point per function where practical—refactor multiple `return`s into a single result variable.  
- Prefer pure functions; isolate side-effects (I/O, mutation) into clearly named wrappers.  
- Always include a “See also” section in docstrings linking to related utilities or modules.  
- Group related functions into modules (e.g. `cluster.py`, `matching.py`, `status.py`) rather than monolithic files.  
- Limit method signatures to at most three parameters; inject dependencies rather than using global state.  
- Format code with **Black** using a maximum line length of 120 characters (`black -l 120`).  
- Use **Poetry** for dependency management and virtual environments.  
- Follow a Cookiecutter-style project layout (`src/`, `tests/`, `pyproject.toml`, `README.md`, `docs/`).  

---

## JavaScript/TypeScript-Specific Rules
- Use **Prettier** (e.g. `prettier --print-width 100`) and **ESLint** (Airbnb or your chosen config).  
- Enforce type safety with TypeScript—no implicit `any`; prefer strict mode.  
- Use ES module syntax (`import`/`export`) whenever possible.  
- Write small, pure functions; separate side-effects into well-named services or hooks.  
- Scaffold projects via a Cookiecutter-like tool or `create-node-package`.  
- Write unit tests with **Jest** or **Mocha**; aim for high coverage and meaningful test cases.  
- Follow Clean Code JS best practices: consistent naming, error handling, and clear formatting.  